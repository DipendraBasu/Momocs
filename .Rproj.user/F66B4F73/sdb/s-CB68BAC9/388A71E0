{
    "contents" : "################################################################################\n# 1.  coo.xxx family : basic and domestic operations\n# 2. shape descriptors for traditional morphometrics\n# 3. plotting coo function and utilities\n################################################################################\n\n\n# 1. coo utilities ------------------------------------------------------------\n# a family of functions that do simple functions on 2d coordinates (further\n# abbreviated as \"shape\" (either outlines, open outlines or lanfmarks)\n# they can be passed either as two-column matrices colnames (\"x\" and \"y\"\n# colnaming is not mandatory) or as a list with $x and $y components.\n# and returns a (named) matrix of coordinates.\n# if you want a list, see ?m2l\n\n\n#' Checks shape\n#'\n#' A simple utility, used internally, mostly in the coo functions and methods.\n#' Returns a matrix, when passed with either a list or a matrix of coordinates.\n#'\n#' @param coo a matrix of (x,y) coordinates or a list.\n#' @return a matrix of (x,y) coordinates.\n#' @family coo\n#' @keywords coo\n#' @export\n#' @examples\n#' coo.check(\"Not a shape\")\n#' coo.check(matrix(1:10, ncol=2))\n#' coo.check(list(x=1:5, y=6:10))\ncoo.check <- function(coo){\n  if (is.matrix(coo)) {return(coo)}\n  if (is.list(coo))   {return(l2m(coo))}\n  stop(\"A list or a matrix of (x, y) coordinates must be provided.\")}\n\n#' Centers coordinates\n#'\n#' Returns a shape centered on the origin.\n#' \n#' @export coo.center\n#' @aliases coo.center\n#' @S3method coo.center default\n#' @S3method coo.center Out\n#' @param coo a matrix of (x,y) coordinates or a list.\n#' @return a matrix of (x,y) coordinates.\n#' @family coo\n#' @keywords coo\n#' @examples\n#' coo.center(matrix(1:10, ncol=2))\n#' coo.center(list(x=1:5, y=6:10))\ncoo.center <- function(coo){UseMethod(\"coo.center\")}\ncoo.center.default <- function(coo){\n  coo <- coo.check(coo)\n  return(apply(coo, 2, function(x) x - mean(x)))}\n\ncoo.center.Out <- function(Out){\n  Out$coo <- lapply(Out$coo, coo.center)\n  return(Out)}\n\n#' Scales coordinates\n#'\n#' Scales the coordinates by a 'scale' factor. If not provided,\n#' assumed to be the centroid size. It involves three steps: centering from current position,\n#' dividing coordinates by 'scale', pusing back to the original position.\n#' \n#' @export coo.scale\n#' @aliases coo.scale \n#' @S3method coo.scale default\n#' @S3method coo.scale Out\n#' \n#' @param coo a matrix of (x,y) coordinates or a list.\n#' @return a matrix of (x,y) coordinates.\n#' @family coo\n#' @keywords coo\n#' @examples\n#' coo.scale(matrix(1:10, ncol=2))\n\ncoo.scale <- function(coo, scale){UseMethod(\"coo.scale\")}\ncoo.scale.default <- function (coo, scale=coo.centsize(coo)) {\n  coo <- coo.check(coo)\n  cp  <- coo.centpos(coo)\n  coo <- coo.trans(coo.trans(coo, -cp[1], -cp[2])/scale, cp[1], cp[2])\n  return(coo)}\ncoo.scale.Out <- function(Out, scale){\n  #dirty loop but had bad time trying to vectorize it\n  if (missing(scale)) {\n    scale <- sapply(Out$coo, coo.centsize)}\n  if (length(scale) != length(Out)) {\n    scale <- rep(scale, length(Out))}\n  for (i in seq(along=Out$coo)){\n    Out$coo[[i]] <- coo.scale(Out$coo[[i]], scale[i])}\n    return(Out)}\n\n#' Rotates coordinates\n#'\n#' Rotates the coordinates by a 'theta' angle (in radians) If not provided,\n#' assumed to be the centroid size. It involves three steps: centering from current position,\n#' dividing coordinates by 'scale', pusing back to the original position.\n#' \n#' @export coo.rotate\n#' @aliases coo.rotate \n#' @S3method coo.rotate default\n#' @S3method coo.rotate Out\n#' \n#' @param coo a matrix of (x,y) coordinates or a \\code{Out} object.\n#' @return a matrix of (x,y) coordinates or a \\code{Out} object.\n#' @family coo\n#' @keywords coo\n#' @examples\n#' coo.rotate(matrix(1:10, ncol=2))\ncoo.rotate <- function(coo, theta=0){UseMethod(\"coo.rotate\")}\ncoo.rotate.default <- function(coo, theta=0){\n  coo <- coo.check(coo)\n  rmat <- matrix(c(cos(theta), sin(theta),\n                  -sin(theta), cos(theta)), nrow=2)\n  return(coo %*% rmat)}\ncoo.rotate.Out <- function(Out, theta=0){\n  Out$coo <- lapply(Out$coo, coo.rotate, theta)}\n  \n  \n#' Aligns coordinates\n#'\n#' Aligns the coordinates along their longer axis using var-cov matrix and eigen values.\n#' \n#' @export coo.align\n#' @aliases coo.align \n#' @S3method coo.align default\n#' @S3method coo.align Out\n#' \n#' @param coo a matrix of (x,y) coordinates or a \\code{Out} object.\n#' @return a matrix of (x,y) coordinates or a \\code{Out} object.\n#' @family coo\n#' @keywords coo\n#' @examples\n#' coo.align(matrix(1:10, ncol=2))\ncoo.align <- function(coo){UseMethod(\"coo.align\")}\ncoo.align.default <- function(coo){\n  coo <- coo.check(coo)\n  return(coo %*% svd(var(coo))$u)}\ncoo.align.Out <- function(Out){\n  Out$coo <- lapply(Out$coo, coo.align)\n  return(Out)}\n\n#' Translates coordinates\n#'\n#' Translates the coordinatesby a 'x' and 'y' value\n#' \n#' @export coo.trans\n#' @aliases coo.trans \n#' @S3method coo.trans default\n#' @S3method coo.trans Out\n#' \n#' @param coo a matrix of (x,y) coordinates or a \\code{Out} object.\n#' @return a matrix of (x,y) coordinates or a \\code{Out} object.\n#' @family coo\n#' @keywords coo\n#' @examples\n#' coo.trans(matrix(1:10, ncol=2), 5, 10)\ncoo.trans <- function(coo, x=0, y=0){UseMethod(\"coo.trans\")}\ncoo.trans.default <- function(coo, x=0, y=0){\n  coo <- coo.check(coo)\n  cbind(coo[, 1] + x, coo[, 2] + y) }\ncoo.trans.Out <- function(Out, x=0, y=0){\n  Out$coo <- lapply(Out$coo, coo.trans, x, y)\n  return(Out)}\n\n# coo.slide \"slides\" the coordinates so that the id1-th coordinates becomes the 1st\ncoo.slide <- function(coo, id1){UseMethod(\"coo.slide\")}\ncoo.slide.default <- function(coo, id1){\n  coo <- coo.check(coo)\n  if (id1 == 0) {return(coo)}\n  n <- nrow(coo)\n  slided.rows <- c(id1:n, 1:(id1-1))\n  return(coo[slided.rows, ])}\ncoo.slide.Out <- function(Out, id1){\n  if (length(Out$ldk)==0) stop(\" * No landmarks defined.\")\n  for (i in seq(along=Out$coo)) {\n    Out$coo[[i]] <- coo.slide(Out$coo[[i]], Out$ldk[[i]][id1])\n    Out$ldk[[i]] <- (Out$ldk[[i]] - (Out$ldk[[i]][id1] -1)) %% nrow(Out$coo[[i]])}\n  return(Out)}\n\n# coo.sample samples \"n\" coordinates among the coordinates provided\ncoo.sample <- function(coo, n){UseMethod(\"coo.sample\")}\ncoo.sample.default <- function (coo, n) {\n  coo <- coo.check(coo)\n  sampled <- round(seq(1, nrow(coo), len = n + 1)[-(n + 1)])\n  return(coo[sampled, ])}\ncoo.sample.Out <- function(Out, n){\n  Out$coo <- lapply(Out$coo, coo.sample, n)\n  return(Out)}\n\n# coo.sample.rr samples \"n\" coordinates with a regular radius\ncoo.sample.rr <- function(coo, n){UseMethod(\"coo.sample.rr\")}\ncoo.sample.rr.default <- function(coo, n){\n  coo <- coo.check(coo)\n  Rx <- coo[, 1]\n  Ry <- coo[, 2]\n  le  <-length(Rx)\n  M   <-matrix(c(Rx, Ry), le, 2)\n  M1  <-matrix(c(Rx-mean(Rx), Ry-mean(Ry)), le, 2)\n  V1  <-complex(real=M1[, 1], imaginary=M1[, 2])\n  M2  <-matrix(c(Arg(V1), Mod(V1)), le, 2)\n  V2  <-NA\n  for (i in 0:(n-1)){\n    V2[i+1] <- which.max((cos(M2[, 1] - 2*i*pi/n)))}\n  V2 <- sort(V2)\n  return(M1[V2, ])}\ncoo.sample.rr.Out <- function(Out, n){\n  Out$coo <- lapply(Out$coo, coo.sample.rr, n)\n  return(Out)}\n\n# coo.sample.int samples/interpolates n coordinates, equally spaced along the\n# perimeter of the coordinates provided and keeping the first point\ncoo.sample.int <- function(coo, n){\n  coo <- coo.check(coo)\n  if (!is.closed(coo)) { coo <- coo.close(coo) }\n  orig <- cumsum(coo.perim.pts(coo))\n  targ <- seq(0, coo.perim(coo), length=n+1)[-(n+1)]\n  coo2 <- matrix(c(coo[1, ], rep(NA, n*2 - 2)), byrow=TRUE, nrow=n, ncol=2)\n  for (i in 2:n) {\n    k <- max(which(orig <= targ[i]))\n    r <- (targ[i] - orig[k]) / (orig[k+1]- orig[k])\n    coo2[i, ] <- edi(coo[k, ], coo[k+1, ], r)}\n  return(coo2)}\ncoo.sample.int.Out <- function(Out){\n  Out$coo <- lapply(Out$coo, coo.sample.int, n)\n  return(Out)}\n\n# coo.smooth smoothes coordinates using a simple weighting moving average\ncoo.smooth <- function(coo, n){UseMethod(\"coo.smooth\")}\ncoo.smooth.default <- function(coo, n=0){\n  coo <- coo.check(coo)\n  p   <- nrow(coo)\n  a   <- 0\n  while (a < n) {\n    a <- a + 1\n    coo.i <- rbind(coo[-1, ], coo[1, ])\n    coo.s <- rbind(coo[p, ],  coo[-p, ])\n    coo   <- coo/2 + coo.i/4 + coo.s/4}\n  return(coo)}\ncoo.smooth.Out <- function(Out, n){\n  Out$coo <- lapply(Out$coo, coo.smooth, n)\n  return(Out)}\n\n#' Tests if shapes are closed\n#'\n#' Returns TRUE/FALSE whether the last coordianate of the shapes is the same\n#' as the first one.\n#' \n#' @export is.closed\n#' @aliases is.closed\n#' @S3method is.closed default\n#' @S3method is.closed Out\n#' @param coo a matrix of (x,y) coordinates or a Out object\n#' @return a boolean.\n#' @family coo\n#' @keywords coo\n#' @examples\n#' is.closed(matrix(1:10, ncol=2))\n\nis.closed <- function(coo){UseMethod(\"is.closed\")}\nis.closed.default <- function(coo){\n  coo <- coo.check(coo)\n  identical(coo[1,], coo[nrow(coo),]) }\nis.closed.Out <- function(Out){sapply(Out$coo, is.closed)}\n\n# # is.likelyopen tries to estimate is a matrix of coordinates is likely to be a\n# # closed polygon\n# is.likelyclosedpolygon <- function(coo) {\n#   x <- coo.perim.pts(coo)\n#   d <- max(x) / median(x[-which.max(x)])\n#   ifelse(d > 3, TRUE, FALSE)}\n\n# coo.close returns a closed shape from an un/closed one.\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.close <- function(coo){UseMethod(\"coo.close\")}\ncoo.close.default <- function(coo){\n  coo <- coo.check(coo)\n  ifelse(is.closed(coo), return(coo), return(rbind(coo, coo[1, ])))}\ncoo.close.Out <- function(Out){\n  Out$coo <- lapply(Out$coo, coo.close)\n  return(Out)}\n\n# coo.unclose returns an unclosed shape from an un/closed one.\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.unclose <- function(coo){UseMethod(\"coo.unclose\")}\ncoo.unclose.default <- function(coo){\n  coo <- coo.check(coo)\n  ifelse(is.closed(coo), return(coo[-nrow(coo), ]), return(coo))}\ncoo.unclose.Out <- function(Out){\n  Out$coo <- lapply(Out$coo, coo.unclose)\n  return(Out)}\n\n# coo.centpos returns the (x, y) centroid coordinates of a shape.\ncoo.centpos <- function(coo){UseMethod(\"coo.centpos\")}\ncoo.centpos.default <- function(coo){\n  coo <- coo.check(coo)\n  return(apply(coo, 2, mean))}\n\ncoo.centpos.Out <- function(Out){\n  centpos <- t(sapply(Out$coo, coo.centpos))\n  colnames(centpos) <- c(\"x\", \"y\")\n  return(centpos)}\n\n# coo.rotate.center rotates a shape of \"theta\" angles (in radians)\n# and with a (x, y) \"center\".\ncoo.rotate.center <- function(coo, theta, center=c(0, 0)){\n  coo <- coo.trans(coo, -center[1], -center[2])\n  coo <- coo.rotate(coo, theta)\n  return(coo.trans(coo, center[1], center[2]))}\n\n# coo.perim returns the distances between every edges of a shape.\ncoo.perim.pts <-  function (coo){\n  coo <- coo.check(coo)\n  n <- nrow(coo)\n  d <- sqrt(apply((coo - coo.slide(coo, n))^2, 1, sum))\n  return(d)}\n\n# coo.bookstein registers a new baseline for the shape, with the ldk1-th\n# and ldk2-th points being set on (-0.5, 0) and (0.5, 0), respectively.\n#coo. <- function(coo){UseMethod(\"coo.\")}\n\ncoo.bookstein <- function(coo, ldk1, ldk2){UseMethod(\"coo.bookstein\")}\ncoo.bookstein.default <- function(coo, ldk1, ldk2){\n  D <- ed(coo[ldk1, ], coo[ldk2, ])\n  coo2 <- matrix(NA, nrow(coo), ncol(coo))\n  ldk1 <- coo[ldk1,]\n  ldk2 <- coo[ldk2,]\n  coo2[, 1] <- (((ldk2[1]-ldk1[1]) * (coo[,1]-ldk1[1])\n                 + (ldk2[2]-ldk1[2]) * (coo[,2]-ldk1[2])) / (D^2)) - 0.5\n  coo2[, 2] <- ((ldk2[1]-ldk1[1])  * (coo[,2]-ldk1[2])\n                - (ldk2[2]-ldk1[2])  * (coo[,1]-ldk1[1])) / (D^2)\n  return(coo2)}\n\ncoo.bookstein.Out <- function(Out, ldk1, ldk2){ #id1 ?\n  for (i in seq(along=Out$coo)){\n    Out$coo[[i]] <- coo.bookstein(Out$coo[[i]], Out$ldk[[i]][ldk1], Out$ldk[[i]][ldk2])}\n  return(Out)}\n  \n  \n  \n  \n  \n\n# coo.baseline is a non-exact baseline registration on t1 and t2 coordinates,\n# for the ldk1-th and ldk2-th points. By default it returns Bookstein's coordinates.\n#coo. <- function(coo){UseMethod(\"coo.\")}\n\ncoo.baseline <- function(coo, ldk1=1, ldk2=2, t1=c(-0.5, 0), t2=c(0.5, 0)){\n  if (is.list(coo)) {coo <- l2m(coo)}\n  t1x <- t1[1]\n  t1y <- t1[2]\n  t2x <- t2[1]\n  t2y <- t2[2]\n  r1x <- coo[ldk1, 1]\n  r1y <- coo[ldk1, 2]\n  r2x <- coo[ldk2, 1]\n  r2y <- coo[ldk2, 2]\n  # translation based on the first landmark\n  ref <- coo.trans(coo, t1x - coo[ldk1, 1] , t1y - coo[ldk1, 2])\n  # we calculate dx and dy for the two vectors\n  rx <- ref[ldk2, 1] - t1x\n  ry <- ref[ldk2, 2] - t1y \n  tx <- t2x - t1x\n  ty <- t2y - t1y\n    # returns difference angle and norm ratios between two vectors given as 4 numeric.\n    vecs.param <- function(r1, i1, r2, i2){\n      x <- c(r1, i1, r2, i2)\n      r.norms <- sqrt((r2^2 + i2^2)) / sqrt((r1^2 + i1^2))\n      d1 <- sqrt(sum(r1^2 + i1^2))\n      d2 <- sqrt(sum(r2^2 + i2^2))\n      return(list(r.norms=d1/d2, d.angle=atan2(i2, r2) - atan2(i1, r1)))}\n  vi <- vecs.param(rx, ry, tx, ty)\n  # we rotate accordingly with a center defined as the first landmark (trans, rot, untrans)\n  ref <- coo.trans(ref, -t1x, -t1y)\n  ref <- ref / vi$r.norms\n  ref <- coo.rotate(ref, -vi$d.angle)\n  ref <- coo.trans(ref, t1x, t1y)\n  return(ref)}\n\n# coo.force2close returns closed shapes so that (if not already closed), it\n# distributes the original dx and dy between the first and last points.\ncoo.force2close <- function(coo){\n  coo <- check.coo\n  if (is.closed(coo)) {return(coo)}\n  n  <- nrow(coo)\n  d  <- coo[1, ] - coo[n, ]\n  dm <- cbind(seq(0, d[1], length=n), seq(0, d[2], length=n))\n  return(coo + dm)}\n\n# coo.up only retains the coordinates with positive/zero y-coordinates\n#coo. <- function(coo){UseMethod(\"coo.\")}\n\ncoo.up <- function(coo){\n  up <- coo[coo[,2]>=0,]\n  return(up)}\n\n# coo.up only retains the coordinates with negative/zero y-coordinates\n#coo. <- function(coo){UseMethod(\"coo.\")}\n\ncoo.down <- function(coo){\n  coo <- coo.check(coo)\n  return(coo[coo[, 2]<=0,])}\n\n# coo.centdist returns, for every point, the distance to the centroid\n#coo. <- function(coo){UseMethod(\"coo.\")}\n\ncoo.centdist <- function(coo){\n  coo <- coo.check(coo)\n  return(apply(coo, 1, function(x) ed(coo.centpos(coo), x)))}\n\n# coo.align.xax align the longest axis of a shape along the x-axis\n#coo. <- function(coo){UseMethod(\"coo.\")}\n\ncoo.align.xax <- function(coo){\n  coo <- coo.check(coo)\n  coo <- coo.align(coo)\n  return(coo.trans(coo, x=0, y=- coo.centpos(coo)[2]))}\n\n# coo.rev returns the reverse suite of coordinates, change shape's orientation\n#coo. <- function(coo){UseMethod(\"coo.\")}\n\ncoo.rev <- function(coo){\n  coo <- coo.check(coo)\n  return(coo[nrow(coo):1,])}\n\n# coo.ldk allows to interactively define a \"nb.ldk\" number of landarks on a shape.\n#coo. <- function(coo){UseMethod(\"coo.\")}\n\ncoo.ldk <- function(coo, nb.ldk) {\n  if (is.list(coo)) coo <- l2m(coo)\n  coo.plot(coo)\n  ldk <- numeric(nb.ldk)\n  cat(\"[\")\n  for (i in 1:nb.ldk){\n    p <- l2m(locator(1))\n    l <- apply(coo, 1, function(y) sqrt(sum((p-y)^2)))\n    ldk[i] <- which.min(l)\n    points(coo[ldk[i], 1], coo[ldk[i], 2], pch=20, col=\"red\", cex=0.5)\n    cat(\"*\")\n  }\n  cat(\"]\\n\")\n  return(ldk)}\n\n# 2. coo shape descriptors -----------------------------------------------------\n\n# coo.centsize returns the centroid size a shape.\n#coo. <- function(coo){UseMethod(\"coo.\")}\n\ncoo.centsize <- function(coo){\n  coo  <- coo.check(coo)\n  cent <- coo.centpos(coo)\n  cs   <- mean(apply(coo, 1, function(x) sqrt(sum((x-cent)^2))))\n  return(cs)}\n\n# coo.perim returns the perimeter of a shape.\n#coo. <- function(coo){UseMethod(\"coo.\")}\n\ncoo.perim <- function(coo){\n  return(sum(coo.perim.pts(coo)))}\n\n# coo.calliper returns the Feret diameter, ie the longest distance that can\n# be found between a pair of coordinates.\n#coo. <- function(coo){UseMethod(\"coo.\")}\n\ncoo.calliper <- function(coo, arr.ind=FALSE){\n  coo <- coo.check(coo)\n  d   <- dist(coo, method = \"euclidean\")\n  # we check if there is no ex aequo\n  ea <- length(which(d==max(d), arr.ind=TRUE))\n  if (length(ea)>1) {cat(\" * coo.length: at least two lengths are ex aequo.\")}\n  if (arr.ind) {\n    arr.ind <- which(as.matrix(d)==max(d), arr.ind=TRUE)\n    # to return a vector (numeric and sorted) of the rows between which the max\n    # length has been found\n    arr.ind <- sort(as.numeric(arr.ind[1, ]))\n    return(list(length=max(d), arr.ind=arr.ind))\n  } else {\n    return(max(d))}}\n\n# coo.lw returns the length and width of a shape based on their iniertia axis\n# ie alignment to the x-axis\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.lw <- function(coo){\n  coo <- coo.check(coo)\n  d   <- apply(coo.align(coo), 2, range)\n  return(abs(d[2,] - d[1,]))}\n\n# coo.area computes the area of any non-crossing shape (in square units)\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.area <- function(coo){\n  coo <- coo.check(coo)\n  coo <- coo.close(coo)\n  nr <- nrow(coo)-1\n  y <- x <- numeric(nr)\n  for (i in 1:nr){\n    x[i] <- coo[i, 1] * coo[i+1, 2]\n    y[i] <- coo[i+1 , 1] * coo[i, 2]\n  }\n  area <- (0.5 * (sum(x) - sum(y)))\n  return(area)}\n\n# coo.theta.3pts returns the angle (in radians) defined by a triplet of points\n# either signed (\"atan2\") or not (\"acos\"). \ntheta3ldk <- function(m, method=c(\"atan2\", \"acos\")[1]){  \n  a <- c(m[1, 1] - m[2, 1], m[1, 2] - m[2, 2])\n  b <- c(m[3, 1] - m[2, 1], m[3, 2] - m[2, 2])\n  if (method==\"atan2\") {\n    return(atan2 (a[1]*b[2]-a[2]*b[1],a[1]*b[1]+a[2]*b[2]))}\n  if (method==\"acos\") {\n    return(acos(sum(a*b)/(sqrt(sum(a*a)) * sqrt(sum(b*b)))))}}\n\n# coo.theta returns the angle (in radians) defined by every triplet of points\n# either signed (\"atan2\") or not (\"acos\"), along the shape.\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.theta.pts <- function(coo, method=c(\"atan2\", \"acos\")[1]){\n  coo <- coo.check(coo)\n  coo <- coo.close(coo)\n  coo   <- rbind(coo[nrow(coo)-1, ], coo)\n  theta <- numeric()\n  for (i in 1:(nrow(coo)-2)){\n    theta[i] <- coo.theta.3pts(coo[i:(i+2),], method=method)\n  }\n  return(theta)}\n\n# coo.rectilinearity returns the rectilinearity measurement by Zunic and Rosin\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.rectilinearity <- function(coo) {\n  # some check\n  coo <- coo.check(coo)\n  if (is.closed(coo)) {\n    coo.c <- coo\n    coo   <- coo.unclose(coo)\n  } else {\n    coo.c <- coo.close(coo)}\n  # we deduce it for the algo\n  n <- nrow(coo)\n  k <- 4*n\n  # here starts the computation as given by Zunic and Rosin\n  # we calculate l1 and l2 for every edge\n  l1 <- function(x1, y1, x2, y2) { abs(x1 - x2) + abs(y1 - y2) }\n  l2 <- function(x1, y1, x2, y2) { sqrt((x1 - x2)^2 + (y1 - y2)^2) }\n  # l2 is redefined here for coherence with the paper, but is equivalent to coo.perim.pts(coo)\n  l2.e <- l1.e <- numeric(n)\n  for (i in 1:n){\n    x1 <- coo.c[i,   1]\n    y1 <- coo.c[i,   2]\n    x2 <- coo.c[i+1, 1]\n    y2 <- coo.c[i+1, 2]\n    l1.e[i] <- l1(x1, y1, x2, y2)\n    l2.e[i] <- l2(x1, y1, x2, y2)} # sum(l2.e) == coo.perim(coo)\n  # \"step 1\" as in Zunic and Rosin\n  theta   <- coo.theta(coo)\n  theta.k <- abs(c(theta - pi/2, theta - pi, theta - 3*pi/2, theta - 2*pi))\n  alpha.k <- sort(theta.k)\n  # \"step 2\" as in Zunic and Rosin\n  P1.Pa <- numeric(k)\n  for (j in 1:k){\n    P1.Pa_n <- numeric(n)\n    for (i in 1:n) {\n      cos.ij <- cos(theta[i] + alpha.k[j])\n      sin.ij <- sin(theta[i] + alpha.k[j])  \n      a.ij <- ifelse(cos.ij > 0, l2.e[i], -l2.e[i])\n      b.ij <- ifelse(sin.ij > 0, l2.e[i], -l2.e[i]) \n      P1.Pa_n[i] <- a.ij*cos.ij + b.ij*sin.ij\n    }\n    P1.Pa[j] <- sum(P1.Pa_n)\n  }\n  # \"step 3\" as in Zunic and Rosin\n  return((4/(4 - pi)) * ((sum(l2.e) / min(P1.Pa)) - (pi/4)))\n}\n\n# coo.circularity.haralick returns Haralick's circularity which is less sensible\n# to digitalization noise than coo.circularity\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.circularity.haralick <- function(coo) {\n  cd <- coo.centdist(coo)\n  return(mean(cd)/sd(cd))}\n\n# coo.circularity, the simplest circularity measure. Also called compactness\n# and shape factor...\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.circularity <- function(coo) {\n  return(coo.perim(coo)^2 / coo.area(coo))}\n\n# coo.circularity.norm returns the circularity, normalised to the unit circle.\ncoo.circularity.norm <- function(coo) {\n  return(coo.perim(coo)^2 / (coo.area(coo)*4*pi))}\n\n# scale dependent...\n# coo.fracdim <- function(coo){\n#   return((2*log(coo.perim(coo))) / log(coo.area(coo)))}\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.eccentricity.eigen <- function(coo){\n  coo <- coo.check(coo)\n  eig <- eigen(cov(coo))$values\n  return(eig[2]/eig[1])}\n\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.eccentricity.boundingbox <- function(coo){\n  coo <- coo.check(coo)\n  lw <- coo.lw(coo)\n  return(lw[2]/lw[1])}\n\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.elongation <- function(coo){\n  coo <- coo.check(coo)\n  lw <- coo.lw(coo)\n  return(1 - lw[2]/lw[1])}\n\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.rectangularity <- function(coo){\n  coo <- coo.check(coo)\n  abr <- prod(coo.lw(coo))\n  return(coo.area(coo)/abr)}\n\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.chull <- function(coo){\n  coo <- coo.check(coo)\n  return(coo[chull(coo),])}\n\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.convexity <- function(coo){\n  coo <- coo.check(coo)\n  return(coo.perim(coo.chull(coo))/coo.perim(coo))}\n\n#coo. <- function(coo){UseMethod(\"coo.\")}\ncoo.solidity <- function(coo){\n  coo <- coo.check(coo)\n  return(coo.area(coo)/coo.area(coo.chull(coo)))}\n\n\n################################################################################\n# 3. plotting coo function and utilities\n# --------------\n################################################################################\n\ncoo.plot <- function(coo, xlim, ylim, border=\"#333333\", col=\"#33333322\", lwd=1, lty=1,\n                     points=FALSE, first.point=TRUE, centroid=TRUE, xy.axis=TRUE,\n                     pch=1, cex=0.5, main, plot.new=TRUE){\n  coo <- coo.check(coo)\n  if (plot.new) {\n    # we setup coo.plot graphical parameters\n    op <- par(mar=c(3, 3, 2, 1))\n    on.exit(par(op))\n    if (!missing(xlim) | !missing(ylim)) {\n      if (missing(xlim)){ xlim <- ylim } else {ylim <- xlim }\n      plot(coo, type=\"n\", asp=1,  las=1, cex.axis=2/3, ann=FALSE, frame=FALSE,\n           xlim=xlim, ylim=ylim)\n    } else {\n      plot(coo, type=\"n\", asp=1,  las=1, cex.axis=2/3, ann=FALSE, frame=FALSE)}\n    if (xy.axis) {abline(h=0, v=0, col=\"grey80\", lty=2)}}\n  polygon(coo, col=col, border=NA)\n  lines(coo, col=border, lwd=lwd, lty=lty)\n  # we handle coordinate points\n  if (missing(points)) { if (nrow(coo)<=100) points(coo, pch=pch, cex=cex, col=border)}\n  if (points) { points(coo, pch=pch, cex=cex, col=border) }\n  if (first.point) {points(coo[1, 1], coo[1, 2], col = border, pch=20)}\n  if (centroid) {\n    cent <- coo.centpos(coo)\n    points(cent[1], cent[2], pch=3, col=border, cex=cex)}\n  if (!missing(main)) title(main=main)} \n\ncoo.draw <- function(coo, ...){\n  coo.plot(coo, plot.new=FALSE, ...)}\n\ncoo.template   <- function(coo, size=1) {\n  # only for matrices\n  coo      <- coo * min(size/apply(coo, 2, function(x) diff(range(x))))\n  expected <- apply(coo, 2, function(x) diff(range(x)))/2\n  observed <- apply(coo, 2, range)[2, ]\n  shift    <-  expected - observed\n  return(coo.trans(coo, shift[1], shift[2]))}\n\ncoo.list.panel <- function(coo.list, dim, byrow=TRUE,\n                           fromtop=TRUE, mar=rep(0, 4),\n                           cols, borders){\n  coo.list <- lapply(coo.list, coo.check)\n  # if dim is missing, we define a square\n  n <- length(coo.list)\n  if(missing(dim)) {\n    nc  <- ceiling(sqrt(n))\n    nr  <- ceiling(n/nc)\n    dim <- c(nr, nc)}\n  k   <- dim[1]*dim[2]\n  if (k < n) stop(\"dim[1]*dim[2] must be >= the length of coo.list\")\n  pos <- matrix(1:k, dim[1], dim[2], byrow=byrow)\n  if (fromtop & dim[1]>1) { pos <- pos[dim[1]:1,] }\n  # we prepare the panel\n  op <- par(\"mar\", \"oma\")\n  on.exit(par(op))\n  par(mar=mar, oma=rep(0.2, 4))\n  plot(NA, asp=1,\n       xlim=c(0, dim[2]),\n       ylim=c(0, dim[1]),\n       xaxs=\"i\", yaxs=\"i\", frame=FALSE, ann=FALSE, axes=FALSE)\n  # we template and plot shapes\n  coo.tp  <- lapply(coo.list, coo.template, size=0.95)\n  if (missing(cols))    { cols      <- rep(\"grey80\", n) }\n  if (missing(borders)) { borders   <- rep(\"grey20\", n) }\n  res <- data.frame(pos.x=numeric(), pos.y=numeric())\n  for (i in 1:n){\n    trans <- which(pos==i, arr.ind=TRUE) - 0.5\n    res[i, ] <- c(trans[2], trans[1])\n    polygon(coo.tp[[i]][, 1] + trans[2],\n            coo.tp[[i]][, 2] + trans[1],\n            col=cols[i], border=borders[i])\n  }\n}\n\ncoo.oscillo <- function(coo, rug=TRUE, legend=TRUE, cols=col.gallus(2), nb.pts=12){\n  coo <- coo.check(coo)\n  nr <- nrow(coo)\n  dx <- coo[, 1] - coo[1, 1]\n  dy <- coo[, 2] - coo[1, 2]\n\n  def.par <- par(no.readonly = TRUE)\n  on.exit(par(def.par))\n  layout(matrix(1:2, ncol=2), widths=c(1, 2))\n  par(mar=c(3, 3, 2 , 1))\n  coo.plot(coo, points=FALSE, first.point=FALSE)\n  box()\n  refs <- round(seq(1, nr, length=nb.pts+1)[-(nb.pts+1)])\n  text(coo[refs, 1], coo[refs, 2], labels=as.character(1:nb.pts), cex=0.7)\n  ry <- max(abs(range(c(dx, dy))))\n  par(mar=c(3, 3, 2 , 1))\n  plot(NA, xlim=c(1, nr), xlab=\"\",\n       ylim=c(-ry, ry)*1.1,   ylab=\"Deviation\",\n       las=1, frame=FALSE, axes=FALSE)\n  axis(2, cex.axis=2/3, las=1)\n  lines(dx, col=cols[1])\n  lines(dy, col=cols[2])\n  text((1:nr)[refs], dx[refs], labels=as.character(1:nb.pts), cex=0.7, col=cols[1])\n  text((1:nr)[refs], dy[refs], labels=as.character(1:nb.pts), cex=0.7, col=cols[2])\n  mtext(\"Deviation\", side=2, line=1.5)\n  box()\n  if (legend) {\n    legend(\"bottomright\", legend = c(expression(x[i] - x[0]), expression(y[i] - y[0])),\n           col = cols, bg=\"#FFFFFFCC\", \n           cex=0.7, lty = 1, lwd=1, inset=0.05, bty=\"n\")}}\n\n\ndev.plot       <- function(mat, dev, cols, x=1:ncol(mat), \n                           lines=TRUE, poly=TRUE, segments=FALSE, bw=0.1,\n                           plot=FALSE, main=\"Deviation plot\", xlab=\"\", ylab=\"Deviations\") {\n  # we prepare and check a bit\n  r <- nrow(mat)\n  if (!missing(dev)){\n    if (any(dim(mat)!=dim(dev))) {\n      stop(\"mat and dev must be of the same dimension\")}}\n  if (missing(cols))   {cols <- rep(\"#000000\", r)}\n  if (length(cols)!=r) {cols <- rep(\"#000000\", r)}\n  # we call a new plot if required\n  if (plot) {\n    if (missing(dev)) {\n      ylim <- range(mat)\n    } else { ylim <- c(min(mat+dev), max(mat+dev)) }\n    plot(NA, xlim=range(x), ylim=ylim, main=main, xlab=xlab, ylab=ylab, las=1, xaxs=\"i\", yaxs=\"i\")\n    axis(1, at=1:ncol(mat))}\n  # if a deviation matrix is provided\n  if (!missing(dev)){\n    for (i in 1:r){\n      # if required, we draw the background polygons\n      if (poly) {\n        polygon(x = c(x, rev(x)),\n                y = c(mat[i, ] - dev[i, ], rev(c(mat[i, ] + dev[i, ]))),\n                col=paste0(cols[i], \"55\"), border=NA)}\n      # if required we draw the dev segments\n      if (segments) {\n        segments(x,    mat[i, ] - dev[i, ], x, mat[i, ]    + dev[i, ], col=cols[i], lwd=0.5)\n        segments(x-bw, mat[i, ] - dev[i, ], x+bw, mat[i, ] - dev[i, ], col=cols[i], lwd=0.5)\n        segments(x-bw, mat[i, ] + dev[i, ], x+bw, mat[i, ] + dev[i, ], col=cols[i], lwd=0.5)}}}\n  # if a dev matrix is not provided, we simply draw lines\n  if (lines) {\n    for (i in 1:nrow(mat)) {\n      if (lines) {\n        lines(x, mat[i, ], col=cols[i], type=\"o\", cex=0.25, pch=20)}}}}\n\n\n\ndev.segments <-function(coo, cols, lwd=1){\n  nr <- nrow(coo)\n  coo <- rbind(coo, coo[1, ])\n  for (i in 1:nr) {\n    segments(coo[i, 1], coo[i, 2], coo[i+1, 1], coo[i+1, 2],\n             col=cols[i], lwd=lwd)}}\n\n\n# from Claude\nconf.ell <- function(x, y, conf=0.95, nb.pts = 60){\n  if (is.matrix(x)) {\n    y <- x[, 2]\n    x <- x[, 1]}\n  centroid <- apply(cbind(x,y), 2, mean)\n  theta.i <- seq(0, 2*pi, length = nb.pts + 1)[-c(nb.pts+1)]\n  z <- cbind(cos(theta.i), sin(theta.i))\n  rad <- qnorm((1 - conf)/2, mean=0, sd=1, lower.tail=FALSE)\n  vcvxy <- var(cbind(x,y))\n  r <- cor(x, y)\n  M1 <- matrix(c(1,1,-1,1), nrow=2, ncol=2)\n  M2 <- matrix(c(var(x), var(y)), nrow=2, ncol=2)\n  M3 <- matrix(c(1+r, 1-r), nrow=2, ncol=2, byrow=TRUE)\n  ellpar <- M1 * sqrt(M2 * M3/2)\n  t(centroid + rad * ellpar %*% t(z))}\n\n####################\n\n# new frame\n.frame <- function(xy, center.origin=FALSE, zoom=1){\n  if (center.origin) {\n    w <- zoom*max(abs(xy))\n    plot(NA, xlim=c(-w, w), ylim=c(-w, w),  asp=1, axes=FALSE, frame=TRUE) \n  } else {\n    w <- zoom*apply(abs(xy), 2, max)\n    plot(xy, xlim=c(-w[1], w[1]), ylim=c(-w[2], w[2]),\n         type=\"n\", asp=1,  axes=FALSE, frame=TRUE)}}\n\n#grid layer\n.grid <- function(xy, nb.grids=3){\n  m <- max(abs(xy))\n  g <- seq(0, m, length=nb.grids)\n  g <- c(g[-1]*-1, g[-1])\n  abline(h=g, v=g, col=\"grey90\", lty=2)\n  abline(h=0, v=0, col=\"grey80\")}\n\n#rug\n.rug <- function(xy, fac, col){\n  if (is.null(fac)) {\n    rug(xy[, 1], ticksize=0.015, side=1, col=\"black\")\n    rug(xy[, 2], ticksize=0.015, side=2, col=\"black\")\n  } else {\n    for (i in seq(along=levels(fac))) {\n      rug(xy[fac==levels(fac)[i], 1], ticksize=0.015, lwd=1, side=1, col=col[i])\n      rug(xy[fac==levels(fac)[i], 2], ticksize=0.015, lwd=1,  side=2, col=col[i])}}}\n\n# convertir en vrai morphospace, à base de plotnew=TRUE/FALSE\n.morphospace <- function(xy, pos.shp, rot, mshape, amp.shp=1,\n                         size.shp=15, border.shp=\"#00000055\", col.shp=\"#00000011\", ...){\n  pos <- pos.shapes(xy, pos.shp=pos.shp)\n  shp <- pca2shp.efourier(pos=pos, rot=rot, mshape=mshape, amp=amp.shp, trans=TRUE)\n  width <- (par(\"usr\")[4] - par(\"usr\")[3]) / size.shp\n  shp <- lapply(shp, coo.scale, 1/width)\n  burp <- lapply(shp, polygon, border=border.shp, col=col.shp)}\n\n.ellipses <- function(xy, fac, conf=0.5, col){\n  for (i in seq(along=levels(fac))) {\n    pts.i <- xy[fac==levels(fac)[i], ]\n    ell.i <- conf.ell(x=pts.i, conf=conf)\n    lines(coo.close(ell.i), col=col[i])\n    points(coo.centpos(pts.i)[1], coo.centpos(pts.i)[2], pch=3, col=col[i])\n  }}\n\n.chull <- function(coo, fac, col){\n  for (i in seq(along=levels(fac))) {\n    chull.i <- coo.chull(coo[fac==levels(fac)[i], ])\n    lines(coo.close(chull.i), col=col[i])}}\n\n.labels <- function(xy, fac, col){\n  for (i in seq(along=levels(fac))) {\n    cent.i <- coo.centpos(xy[fac==levels(fac)[i], ])\n    text(cent.i[1], cent.i[2], labels=levels(fac)[i], col=col[i], pos=3)}}\n\n.stars <- function(xy, fac, col){\n  col.i <- paste0(col, \"55\")\n  for (i in seq(along=levels(fac))) {\n    pts.i  <- xy[fac==levels(fac)[i], ]\n    cent.i <- coo.centpos(pts.i)\n    for (j in 1:nrow(pts.i)){\n      segments(cent.i[1], cent.i[2], pts.i[j, 1], pts.i[j, 2], col=col.i[i])}}}\n\n.eigen <- function(ev, xax, yax, ratio=0.12){\n  plt0 <- par(\"plt\")\n  on.exit(par(plt = plt0))\n  g <- 0.015\n  w <- min(c(plt0[2]-plt0[1]), plt0[4]-plt0[3])*ratio\n  par(plt = c(plt0[2]-w-g, plt0[2]-g, plt0[3]+g*1.5, plt0[3]+w+g*1.5), xpd=NA, new = TRUE)\n  cols <- rep(\"grey80\", 5)\n  cols[c(xax,yax)] <- \"grey40\"\n  var <- ev^2\n  cs.var <- cumsum(var)/sum(var)\n  k <- ifelse(max(c(xax, yax))>5, max(c(xax, yax)), 5)\n  barplot(var[1:k], axes=FALSE, col=cols, border=NA)\n  text(-0.7, par(\"usr\")[3], labels=\"Eigenvalues\", pos=4, cex=0.6, srt=90, col=\"grey40\")\n  \n}\n\n.axisnames <- function(xax, yax){\n  gx <- strwidth(\"PCN\")/1.75\n  gy <- strheight(\"PCN\")/1.8\n  text(par(\"usr\")[2]-gx, gy, col=\"grey40\", cex=0.8,\n       labels=paste0(\"PC\", xax))\n  text(-gy, par(\"usr\")[4]-gx, col=\"grey40\",cex=0.8,\n       labels=paste0(\"PC\", yax), srt=90)}\n\n.axisvar <- function(ev, xax, yax){\n  var <- ev^2\n  var <- signif(100*var/sum(var), 3)\n  gx <- strwidth(\"00.0%\")/1.75\n  gy <- strheight(\"00.0%\")/1.8\ntext(par(\"usr\")[2]-gx, -gy, col=\"grey40\", cex=0.8,\n     labels=paste0(var[xax], \"%\"))\ntext(+gy, par(\"usr\")[4]-gx, col=\"grey40\",cex=0.8,\n     labels=paste0(var[yax], \"%\"), srt=90)}\n\n.title <- function(title){\n  pos <- par(\"usr\")\n  text(pos[1], pos[3]+ strheight(title), labels=title, pos=4)}\n\n\npca2shp.efourier <- function (pos, rot, mshape, amp=1, nb.pts=60, trans=TRUE) {\n  if (ncol(pos) != ncol(rot)) stop(\"'rot' and 'pos' must have the same ncol\")\n  if(length(mshape) != nrow(rot)) stop(\"'mshape' and ncol(rot) lengths differ\")\n  # stupid function\n  mprod <- function(m, s){\n    res <- m\n    for (i in 1:ncol(m)) { res[, i] <- m[, i]*s[i] }\n    return(res)}\n  nb.h <- length(mshape)/4\n  n  <- nrow(pos)\n  # we prepare the array\n  res <- list()\n  for (i in 1:n) {\n    ax.contrib <- mprod(rot, pos[i, ])*amp\n    coe        <- mshape + apply(ax.contrib, 1, sum)\n    xf         <- coeff.split(coe)\n    coo        <- efourier.i(xf, nb.h = nb.h, nb.pts=nb.pts)\n    if (trans) {coo <- coo.trans(coo, x=pos[i, 1], y=pos[i, 2])}\n  res[[i]] <- coo}\n  return(res)}\n\npos.shapes <- function(xy, pos.shp=c(\"range\", \"circle\")[1],\n                       nb.shp=12, nr.shp=6, nc.shp=5, circle.r.shp){\n  if (is.data.frame(pos.shp) | is.matrix(pos.shp)) {\n    return(as.matrix(pos.shp))}\n  if (pos.shp==\"circle\") {\n    if (missing(circle.r.shp)) {\n      # mean distance from origin\n      circle.r.shp <- mean(apply(xy, 1, function(x) sqrt(sum(x^2))))}\n    t <- seq(0, 2*pi, len=nb.shp+1)[-(nb.shp+1)]\n    pos <- cbind(circle.r.shp*cos(t), circle.r.shp*sin(t))\n    colnames(pos) <- c(\"x\", \"y\") # pure cosmetics\n    return(pos)}\n  if (pos.shp==\"range\") {\n    pos <- expand.grid(seq(min(xy[, 1]), max(xy[, 1]), len=nr.shp),\n                       seq(min(xy[, 2]), max(xy[, 2]), len=nc.shp))\n    pos <- as.matrix(pos)\n    colnames(pos) <- c(\"x\", \"y\") # pure cosmetics\n    return(pos)}\n  if (pos.shp==\"full\") {\n#     w <- par(\"usr\")\n#     pos <- expand.grid(seq(w[1], w[2], len=nr.shp),\n#                        seq(w[3], w[4], len=nc.shp))\n         w <- par(\"usr\")\n         pos <- expand.grid(seq(par(\"xaxp\")[1]*0.9, par(\"xaxp\")[2]*0.9, len=nr.shp),\n                            seq(par(\"yaxp\")[1]*0.9, par(\"yaxp\")[2]*0.9, len=nc.shp))\n    pos <- as.matrix(pos)\n    colnames(pos) <- c(\"x\", \"y\") # pure cosmetics\n    return(pos)   \n  }\n  # if a non-valid method is passed\n  return(xy)}\n\n# Datasets ---------------------------------------------------------------------\n\n#' Outline coordinates of 20 beer and 20 whisky bottles.\n#' \n#' @docType data\n#' @name bot\n#' @keywords datasets\n#' @format An Out object containing the outlines coordinates and a grouping factor\n#' for 20 beer and 20 whisky bottles\n#' @source  Images have been grabbed on the internet and prepared by the package's\n#' authors. No particular choice has been made on the dimension of the original\n#' images or the brands cited here.\nNULL\n\n#' Outline coordinates of 50 cephalic outlines of trilobite\n#' \n#' @docType data\n#' @name trilo\n#' @keywords datasets\n#' @format An Out object 64 coordinates of 50 cephalic outlines from different\n#' ontogenetic stages of trilobite.\n#' @source  Arranged from: \\url{http://folk.uio.no/ohammer/past/outlines.dat}.\n#' The original data included 51 outlines and 5 ontogenetic stages, \n#' but one of them has just a single outline thas has been removed.\n\nNULL\n\n\n#' Outline coordinates of 126 mosquito wings.\n#' \n#' @docType data\n#' @name mosquito\n#' @keywords datasets\n#' @format An Out object with the 126 mosquito wing outlines outlines\n#' used Rohlf and Archie (1984).\n#' @source Rohlf F, Archie J. 1984. A comparison of Fourier methods for the\n#' description of wing shape in mosquitoes (Diptera: Culicidae). \\emph{Systematic Biology}: 302-317.\n#' Arranged from: \\url{http://life.bio.sunysb.edu/morph/data/RohlfArchieWingOutlines.nts}.\nNULL\n\n#' Outline coordinates of 240 hand-drawn hearts\n#' \n#' @docType data\n#' @name hearts\n#' @keywords datasets\n#' @format An Out object with the outline coordinates of 240 hand-drawn hearts\n#' by 8 different persons, with 4 landmarks.\n#' @source We thank the fellows of the Ecology Department of the French Institute\n#' of Pondicherry that drawn the hearts, that then have been smoothed, scaled, centered, and reduced to 80 coordinates per outline.\nNULL\n\n",
    "created" : 1396263242052.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3682001124",
    "id" : "388A71E0",
    "lastKnownWriteTime" : 1396267114,
    "path" : "~/Research/Momocs/R/global.R",
    "project_path" : "R/global.R",
    "properties" : {
    },
    "source_on_save" : true,
    "type" : "r_source"
}