{
    "contents" : "\nOutCoe <- function(coe.matrix, fac=data.frame(), method){\n  if (missing(method)) stop(\"a method must be provided to Coe\")\n  OutCoe <- list(coe=coe.matrix, fac=fac, method=method)\n  class(OutCoe) <- \"OutCoe\"\n  return(OutCoe)}\n\n# The print method for Out objects\nprint.OutCoe <- function(OutCoe){\n  p <- pmatch(OutCoe$method, c(\"eFourier\", \"rFourier\", \"tFourier\"))\n  met <- switch(p, \"elliptical Fourier\", \"radii variation\", \"tangent angle\")\n  ### Header\n  cat(\"An OutCoe object [\", met, \"analysis ] (see ?OutCoe) \\n\")\n  cat(rep(\"-\", 20),\"\\n\", sep=\"\")\n  coo.nb  <- nrow(OutCoe$coe) #nrow method ?\n  harm.nb <- ncol(OutCoe$coe)/ifelse(p == 1, 4, 2)\n  # number of outlines and harmonics\n  cat(\" -\", coo.nb, \"outlines described\\n\")\n  cat(\" -\", coo.nb, \"harmonics\\n\")\n  # lets show some of them for a quick inspection\n  cat(\" - Some harmonic coefficients from random outlines in $coe: \\n\")\n  row.eg <- sort(sample(coo.nb, 5, replace=FALSE))\n  col.eg <- coeff.sel(retain=ifelse(harm.nb > 3, 3, harm.nb), drop=0,\n                      nb.h=harm.nb, cph=ifelse(p==1, 4, 2))\n  print(signif(OutCoe$coe[row.eg, col.eg], 3))\n  cat(\"etc.\\n\")\n  # number of grouping factors\n  df <- OutCoe$fac\n  nf <- ncol(df)\n  if (nf==0) {\n    cat(\" - No groups defined\\n\")\n  } else {\n    cat(\" -\", nf, \"grouping factor(s) defined:\\n\")\n    for (i in 1:nf) {\n      cat(\"     \", colnames(df)[i], \": \", levels(df[, i]),\"\\n\")}}}\n\npca <- function(x, ...){UseMethod(\"pca\")}\npca.OutCoe <- function(OutCoe){\n  PCA <- prcomp(OutCoe$coe, scale.=FALSE, center=TRUE)\n  PCA$fac <- OutCoe$fac\n  PCA$mshape <- apply(OutCoe$coe, 2, mean)\n  class(PCA) <- c(\"OutPCA\", class(PCA))\n  return(PCA)}\n\nplot.OutPCA <- function(#basics\n  PCA, fac, xax=1, yax=2, \n  #color choice\n  col=\"black\", pch=20, palette=col.summer2,\n  #.frame\n  center.origin=FALSE, zoom=1,\n  #.grid\n  grid=TRUE, nb.grids=3,\n  #shapes\n  morphospace=TRUE, pos.shp=\"full\", amp=1,\n  size.shp=20, border.shp=\"#00000055\", col.shp=\"#00000011\",\n  #stars\n  stars=TRUE,\n  #ellipses\n  ellipses=TRUE, conf=0.5,\n  #convexhulls\n  chull=TRUE,\n  #labels\n  labels=TRUE,\n  #axisnames\n  axisnames=TRUE,\n  #axisvar\n  axisvar=TRUE,\n  #eigen\n  eigen=TRUE,\n  #\n  rug=TRUE,\n  title=substitute(PCA)\n){\n  xy <- PCA$x[, c(xax, yax)]\n  # we check and prepare\n  if (!missing(fac)) {\n    if (!is.factor(fac)) { fac <- factor(PCA$fac[, fac]) }\n    if (missing(col)) {\n      col.groups <- palette(nlevels(fac))\n      col <- col.groups[fac]}\n    if (!missing(pch)) {\n      if (length(pch)==nlevels(fac)) { pch <- pch[fac] }}}\n  opar <- par(mar = par(\"mar\"), xpd=FALSE)\n  on.exit(par(opar))\n  par(mar = rep(0.1, 4)) #0.1\n  \n  .frame(xy, center.origin, zoom=zoom)\n  if (grid) .grid(xy)\n  .morphospace(xy, pos.shp=pos.shp, rot=PCA$rotation[, c(xax, yax)], mshape=PCA$mshape,\n               size.shp=size.shp, border.shp=border.shp, col.shp=col.shp)\n  if (!missing(fac)) {\n    if (stars)    .stars(xy, fac, col.groups)\n    if (ellipses) .ellipses(xy, fac, conf=conf, col.groups) #+conf\n    if (chull)    .chull(xy, fac, col.groups)\n    if (labels)   .labels(xy, fac, col.groups)\n    if (rug)      .rug(xy, fac, col.groups)\n  } else {\n    if (rug)      .rug(xy, NULL, col)\n  }\n  points(xy, pch=pch, col=col)\n  if (axisnames)  .axisnames(xax, yax)\n  if (axisvar)    .axisvar(PCA$sdev, xax, yax)\n  .title(title)\n  if (eigen)     .eigen(PCA$sdev, xax, yax)\n  box()}\n\n#c OutCoe\n# boxpltoCoe\n#hist\n\n#pca\n#hcontrib\n#deprecate ellipse par\n#manova\n#meanshape\n#clust\n#discri\n\n#### eigen barplot en rouge dudi.plot\n\n\n\n\n\n",
    "created" : 1396267052112.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3002669736",
    "id" : "ABF88448",
    "lastKnownWriteTime" : 1396267108,
    "path" : "~/Research/Momocs/R/OutCoe.R",
    "project_path" : "R/OutCoe.R",
    "properties" : {
    },
    "source_on_save" : true,
    "type" : "r_source"
}