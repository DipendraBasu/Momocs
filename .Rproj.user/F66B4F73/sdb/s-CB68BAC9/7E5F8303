{
    "contents" : "#todo Out.check\n# Out.nbh check etc. coderepété sur 10 lines\n# smooth.it -> nb.s ?\n\n# xFourier methods -------------------------------------------------------------\neFourier     <- function(Out, nb.h, smooth.it=0, norm=TRUE, start=FALSE){\n  UseMethod(\"eFourier\")}\n\neFourier.Out <- function(Out, nb.h, smooth.it=0, norm=TRUE, start=FALSE){\n  q <- floor(min(sapply(Out$coo, nrow)/2)) - 1\n  if (missing(nb.h))  {\n    nb.h <- ifelse(q >= 32, 32, q)\n    cat(\" * 'nb.h' not provided and set to\", nb.h, \"\\n\")}\n  if(nb.h  > (q+1)*2) {\n    nb.h <- q # should not be 1 #todo\n    warning(\" * at least one outline has no more than \", (q+1)*2, \" coordinates. \n            'nb.h' has been set to: \", q,\"\\n\")}\n  coo <- Out$coo\n  col.n <- paste0(rep(LETTERS[1:4], each = nb.h), rep(1:nb.h, times = 4))\n  coe <- matrix(ncol = 4 * nb.h, nrow = length(coo), dimnames = list(names(coo), col.n))\n  for (i in seq(along = coo)) { #todo: vectorize ?\n    ef <- efourier(coo[[i]], nb.h = nb.h, smooth.it = smooth.it, verbose = TRUE)\n    if (norm) {\n      ef <- efourier.norm(ef, start=start)\n      if (ef$A[1] < 0) {\n        ef$A <- (-ef$A)\n        ef$B <- (-ef$B)\n        ef$C <- (-ef$C)\n        ef$D <- (-ef$D)\n        ef$lnef <- (-ef$lnef)}\n      coe[i, ] <- c(ef$A, ef$B, ef$C, ef$D)\n    } else {\n      coe[i, ] <- c(ef$an, ef$bn, ef$cn, ef$dn)}}\n  return(OutCoe(coe=coe, fac=Out$fac, method=\"eFourier\"))}\n  \nrFourier <- function(Out, nb.h = 40, nb.smooth = 0, norm =TRUE){\n  UseMethod(\"rFourier\")}\n\nrFourier.Out <- function(Out, nb.h = 40, smooth.it = 0, norm = TRUE) {\n  q <- floor(min(sapply(Out$coo, nrow)/2)) - 1\n  if (missing(nb.h))  {\n    nb.h <- ifelse(q >= 32, 32, q)\n    cat(\" * nb.h not provided and set to\", nb.h, \"\\n\")}\n  if(nb.h  > (q+1)*2) {\n    nb.h <- q # should not be 1 #todo\n    warning(\"* at least one outline has no more than \", (q+1)*2, \" coordinates. \n            'nb.h' has been set to: \", q,\"\\n\")}\n  coo <- Out$coo\n  col.n <- paste0(rep(LETTERS[1:2], each = nb.h), rep(1:nb.h, times = 2))\n  coe <- matrix(ncol = 2 * nb.h, nrow = length(coo), dimnames = list(names(coo), col.n))\n  for (i in seq(along = coo)) {\n    rf <- rfourier(coo[[i]], nb.h = nb.h, smooth.it = smooth.it, norm=norm, verbose = TRUE) #todo: vectorize\n    coe[i, ] <- c(rf$an, rf$bn)}\n  return(OutCoe(coe, fac=Out$fac, method=\"rFourier\"))}\n\ntFourier <- function(Out, nb.h = 40, smooth.it = 0, norm =TRUE){\n  UseMethod(\"tFourier\")}\n\ntFourier.Out <- function(Out, nb.h=40, smooth.it = 0, norm=TRUE){\n  q <- floor(min(sapply(Out$coo, nrow)/2)) - 1\n  if (missing(nb.h))  {\n    nb.h <- if (q >= 32) { 32 } else { q }\n    cat(paste(\"  * nb.h not provided and set to\", nb.h, \"\\n\"))}\n  if(nb.h  > (q+1)*2) {\n    nb.h <- q # should not be 1\n    warning(\"At least one outline has no more than \", (q+1)*2, \" coordinates. \n            'nb.h' has been set to: \", q, \"\\n\")}\n  coo <-Out$coo\n  col.n <- paste0(rep(LETTERS[1:2], each = nb.h), rep(1:nb.h, times = 2))\n  coe <- matrix(ncol = 2 * nb.h, nrow = length(coo), dimnames = list(names(coo), col.n))\n  for (i in seq(along = coo)) {\n    tf <- tfourier(coo[[i]], nb.h = nb.h, smooth.it = smooth.it, norm=norm, verbose=TRUE)\n    coe[i, ] <- c(tf$an, tf$bn)}\n  return(OutCoe(coe, fac=Out$fac, method=\"tFourier\"))}\n\n\n# # hqual ##########################################################\n# setGeneric(name= \"hqual\",     def=function(\n#   Coo,\n#   method = c(\"efourier\", \"rfourier\", \"tfourier\"), \n#   id        = sample(Coo@coo.nb, 1),\n#   smooth.it = 0,\n#   harm.range= c(1, 2, 4, 8, 16, 32),\n#   scale = TRUE,\n#   center = TRUE,\n#   align = TRUE,\n#   plot.method = c(\"stack\", \"panel\")[1],\n#   legend = TRUE,\n#   legend.title = \"# harmonics\",\n#   palette = col.summer,\n#   shp.col=\"#70809033\",\n#   shp.border=\"#708090EE\"){standardGeneric(\"hqual\")})\n# \n# setMethod(f=\"hqual\", signature=\"Coo\", definition=\n#             function(Coo,\n#                      method = c(\"efourier\", \"rfourier\", \"tfourier\"),\n#                      id        = sample(Coo@coo.nb, 1),\n#                      smooth.it = 0,\n#                      harm.range= c(1, 2, 4, 8, 16, 32),\n#                      scale = TRUE,\n#                      center = TRUE,\n#                      align = TRUE,\n#                      plot.method = c(\"stack\", \"panel\")[1],\n#                      legend = TRUE,\n#                      legend.title = \"# harmonics\",\n#                      palette = col.summer,\n#                      shp.col=\"#70809033\",\n#                      shp.border=\"#708090EE\"){\n#               # for one single outline\n#               if (missing(method)) {\n#                 cat(\" * Method not provided. efourier is used.\\n\")\n#                 method   <- efourier\n#                 method.i <- efourier.i \n#               } else {\n#                 p <- pmatch(tolower(method), c(\"efourier\", \"rfourier\", \"tfourier\"))\n#                 if (is.na(p)) { warning(\" * Unvalid method. efourier is used.\\n\")\n#                 } else {\n#                   method   <- switch(p, efourier,   rfourier,   tfourier)\n#                   method.i <- switch(p, efourier.i, rfourier.i, tfourier.i)}}\n#               \n#               # check for too ambitious harm.range\n#               if (max(harm.range) > (min(Coo@coo.len)/2 + 1)) {\n#                 harm.range <- floor(seq(1, q/2 - 1, length=6))\n#                 cat(\" * harm.range was too high and set to: \", harm.range, \".\\n\")}\n#               coo <- Coo@coo[[id]]\n#               if (scale)  coo <- coo.scale(coo)\n#               if (center) coo <- coo.center(coo)\n#               if (align)  coo <- coo.align(coo)\n#               res <- list()\n#               for (i in seq(along=harm.range)) {\n#                 res[[i]] <- method.i(method(coo, nb.h=max(harm.range), smooth.it=smooth.it), nb.h=harm.range[i])}\n#               # plotting\n#               op <- par(no.readonly = TRUE)\n#               on.exit(par(op))\n#               cols <- paste(palette(length(harm.range)), \"88\", sep=\"\")\n#               if (plot.method==\"stack\") {\n#                 coo.plot(coo.smooth(coo, smooth.it), main=Coo@names[id], col=shp.col, border=shp.border)\n#                 for (i in seq(along=harm.range)) {lines(res[[i]], col=cols[i], lwd=1)}\n#                 if (legend) {\n#                   legend(\"topright\", legend = as.character(harm.range), bty=\"o\",\n#                          col = cols, lty = 1, lwd=1, bg=\"#FFFFFFCC\", cex=0.7,\n#                          title = legend.title)}\n#                 if (center) {points(0, 0, pch=3, col=shp.col)}\n#               } else {\n#                 if (plot.method==\"panel\") {\n#                   #par(oma=c(1, 1, 3, 0))\n#                   pos <- coo.list.panel(res, cols=cols)\n#                   if (legend) {text(x=pos[, 1], y=pos[, 2], as.character(harm.range))}\n#                   mtext(Coo@names[id], side=3, line=0, cex=1.3, outer=TRUE)\n#                 }}})\n# \n# # hquant #########################################################\n# setGeneric(name= \"hquant\", def=function(\n#   Coo,\n#   method = c(\"efourier\", \"rfourier\", \"tfourier\"),\n#   id        = 1,\n#   smooth.it = 0,\n#   harm.range = seq(4, 20, 4),\n#   norm.centsize = TRUE,\n#   dist.method = edm.nearest,\n#   dist.nbpts = 120,\n#   plot = TRUE,\n#   dev.plot=TRUE,\n#   title = \"Deviations along the outline\",\n#   legend = TRUE,\n#   legend.title = \"# harmonics\",\n#   palette = col.summer,\n#   lineat.y=c(0.5, 0.1, 0.01)){standardGeneric(\"hquant\")})\n# \n# setMethod(f=\"hquant\", signature=\"Coo\", definition=\n#             function(Coo,\n#                      method = c(\"efourier\", \"rfourier\", \"tfourier\"),\n#                      id        = 1,\n#                      smooth.it = 0,\n#                      harm.range= seq(4, 20, 4),\n#                      norm.centsize = TRUE,\n#                      dist.method = edm.nearest,\n#                      dist.nbpts = 120,\n#                      plot = TRUE,\n#                      dev.plot=TRUE,\n#                      title = \"Deviations along the outline\",\n#                      legend = TRUE,\n#                      legend.title = \"# harmonics\",\n#                      palette = col.summer,\n#                      lineat.y=c(0.5, 0.1, 0.01)){\n#               if (missing(method)) {\n#                 cat(\"  * Method not provided. efourier is used.\\n\")\n#                 method   <- efourier\n#                 method.i <- efourier.i \n#               } else {\n#                 p <- pmatch(tolower(method), c(\"efourier\", \"rfourier\", \"tfourier\"))\n#                 if (is.na(p)) { warning(\"Unvalid method. efourier is used.\")\n#                 } else {\n#                   method   <- switch(p, efourier,   rfourier,   tfourier)\n#                   method.i <- switch(p, efourier.i, rfourier.i, tfourier.i)}}\n#               # We define the highest possible nb.h along Coo@coo[id]\n#               min.nb.pts <- min(unlist(lapply(Coo@coo[id], nrow)))\n#               nb.h.best  <- floor(min.nb.pts/2)-1\n#               # we handle too ambitious harm.range\n#               if (max(harm.range) > nb.h.best) {\n#                 harm.range <- floor(seq(4, nb.h.best, length=6))\n#                 cat(\"  * 'harm.range' was too high and set to: \", harm.range, \".\\n\")}\n#               \n#               # we prepare the results array\n#               nb.pts <- ifelse(dist.nbpts == \"max\", 2*nb.h.best, dist.nbpts)\n#               nr <- length(harm.range)\n#               nc <- nb.pts\n#               nk <- length(id)\n#               res <- array(NA, dim=c(nr, nc, nk),\n#                            dimnames=list(paste0(\"h\", harm.range),\n#                                          paste(\"pt\", 1:nb.pts),\n#                                          Coo@names[id]))\n#               # progressbar\n#               if (nk > 5) {\n#                 pb <- txtProgressBar(1, nk)\n#                 t <- TRUE } else {t <- FALSE}\n#               # the core loops that will calculate deviations\n#               for (ind in seq(along=id)) {\n#                 coo <- Coo@coo[[id[ind]]]\n#                 # below, the best possible fit\n#                 coo.best <- l2m(method.i(method(coo, nb.h=nb.h.best, smooth.it=smooth.it), nb.pts=nb.pts))\n#                 for (i in seq(along=harm.range)) {\n#                   # for each number of harmonics we calculate deviation with the FUN=method\n#                   coo.i <- l2m(method.i(method(coo, nb.h=harm.range[i], smooth.it=smooth.it, silent=TRUE), nb.pts=nb.pts))\n#                   res[i, , ind] <- dist.method(coo.best, coo.i)\n#                 }\n#                 # we normalize by the centroid size\n#                 if (norm.centsize) {res[,,ind] <- res[,,ind]/coo.centsize(coo)}\n#                 if (t) setTxtProgressBar(pb, ind)}\n#               # below we manage for single/several individuals\n#               if (nk > 1) { # if more than 1, we calculate median and sd\n#                 m <- apply(res, 1:2, median)\n#                 d <- apply(res, 1:2, sd)\n#               } else {\n#                 m <- res[,,1]\n#                 d <- NULL}\n#               # plotting stuff\n#               if (plot) {\n#                 cols <- palette(nr)\n#                 if (nk > 1) {ylim <- c(0, max(m+d, na.rm=TRUE))} else {ylim <- range(m)}\n#                 if (norm.centsize) {\n#                   ylab = \"Deviation (in % of the centroid size)\"\n#                 } else {\n#                   ylab = \"Deviation (in original units)\"}\n#                 plot(NA, xlim=c(1, nc), ylim=ylim,\n#                      xlab=\"Points sampled along the outline\",\n#                      ylab=ylab, main=title,\n#                      xaxs=\"i\", yaxs=\"i\", axes=FALSE)\n#                 axis(1, at=seq(0, dist.nbpts, length=5))\n#                 axis(2)\n#                 abline(h=lineat.y, lty=2, col=\"grey90\")\n#                 # if you want deviations, here they are\n#                 if (dev.plot) {\n#                   if (nk > 1) {dev.plot(m, d, cols=cols) } else {\n#                     for (i in 1:nr) {\n#                       lines(1:ncol(m), m[i, ], col=cols[i])}}}\n#                 # same for legend\n#                 if (legend) {\n#                   legend(\"topright\", legend = as.character(harm.range), bty=\"o\",\n#                          col = cols, lty = 1, lwd=1, bg=\"#FFFFFFCC\", inset=0.005, cex=0.7,\n#                          title = legend.title)}\n#                 box() }\n#               return(list(res=res, m=m, d=d))})\n# \n# # harm.pow ###########################################################\n# setGeneric(name= \"hpow\", def=function(    \n#   Coo,\n#   method = c(\"efourier\", \"rfourier\", \"tfourier\"),\n#   id=1:Coo@coo.nb,\n#   probs=c(0, 0.5, 1),\n#   nb.h = 24,\n#   drop   = 1,\n#   smooth.it = 0,\n#   plot = TRUE,\n#   legend = FALSE,\n#   title=\"Fourier power spectrum\",\n#   lineat.y=c(0.9, 0.95, 0.99, 0.999),\n#   bw=0.1){standardGeneric(\"hpow\")})\n# \n# setMethod(f=\"hpow\", signature=\"Coo\", definition=\n#             function(Coo,\n#                      method = c(\"efourier\", \"rfourier\", \"tfourier\"),\n#                      id=1:Coo@coo.nb,\n#                      probs=c(0, 0.5, 1),\n#                      nb.h = 24,\n#                      drop   = 1,\n#                      smooth.it = 0,\n#                      plot = TRUE,\n#                      legend = FALSE,\n#                      title=\"Fourier power spectrum\",\n#                      lineat.y=c(0.9, 0.95, 0.99, 0.999),\n#                      bw=0.1) {\n#               # for one signle outline\n#               if (missing(method)) {\n#                 cat(\"  * Method not provided. efourier is used.\\n\")\n#                 method   <- efourier\n#               } else {\n#                 p <- pmatch(tolower(method), c(\"efourier\", \"rfourier\", \"tfourier\"))\n#                 if (is.na(p)) { warning(\"Unvalid method. efourier is used.\")\n#                 } else {\n#                   method   <- switch(p, efourier,   rfourier,   tfourier)}}\n#               res <- matrix(nrow=length(id), ncol=(nb.h-drop))\n#               x <- (drop+1) : nb.h\n#               for (i in seq(along=id)) {\n#                 xf  <- method(Coo@coo[[id[i]]], nb.h = nb.h, smooth.it = smooth.it)\n#                 pow <- harm.pow(xf)[x]\n#                 res[i, ] <-  (cumsum(pow)/sum(pow))}\n#               res <- apply(res, 2, quantile, probs=probs)\n#               rownames(res) <- paste(\"q\", probs)\n#               colnames(res) <- paste(\"h\", x, sep=\"\")\n#               if (plot){\n#                 if (length(probs)!=3) stop(\"probs of length != 3 are not (yet) supported\")  \n#                 plot(NA, xlim = range(x), ylim = c(min(res), 1), las=1, yaxs=\"i\", \n#                      xlab = \"Number of harmonics included\", ylab = \"Cumulative harmonic power\",\n#                      main=title, sub=paste(length(id), \"outlines\"), axes=FALSE)\n#                 axis(1, at=x) ; axis(2)\n#                 abline(h=lineat.y, lty=2, col=\"grey90\")\n#                 segments(x,    res[1, ], x,    res[3, ], lwd=0.5)\n#                 segments(x-bw, res[1, ], x+bw, res[1, ], lwd=0.5)\n#                 segments(x-bw, res[3, ], x+bw, res[3, ], lwd=0.5)\n#                 lines(x, res[2, ], type=\"o\", pch=20, cex=0.6) \n#                 if (legend) {\n#                   legend(\"topright\", legend = as.character(probs), bty=\"o\", lwd=1,\n#                          bg=\"#FFFFFFCC\", cex=0.7, inset = 0.005,\n#                          title = \"Quantiles\")}\n#                 box()\n#               }\n#               return(res)})\n# \n# # Ptolemy ############################################################\n# setGeneric(name=\"Ptolemy\", def=function(Coo,\n#                                         id=1,\n#                                         t=seq(0, 2*pi, length=7)[-1],\n#                                         nb.h=3,\n#                                         nb.pts=360,\n#                                         palette=col.sari,\n#                                         legend=FALSE){standardGeneric(\"Ptolemy\")}) \n# \n# setMethod(f=\"Ptolemy\", signature=\"Coo\", definition=\n#             function(Coo,\n#                      id=1,\n#                      t=seq(0, 2*pi, length=7)[-1],\n#                      nb.h=3,\n#                      nb.pts=360,\n#                      palette=col.sari,\n#                      legend=FALSE) {    # we prepare and deduce\n#               op <- par(no.readonly = TRUE)\n#               on.exit(par(op))\n#               par(xpd=NA)\n#               cols <- palette(nb.h)\n#               coo <- coo.center(Coo@coo[[id]])\n#               #k <- floor(length(coo$x)/4)\n#               coo.plot(coo, main=Coo@names[id])\n#               # now we calculate for every harmonic\n#               coo.ef  <- efourier(coo, nb.h)\n#               coo.efi <- efourier.i(coo.ef, nb.h, nb.pts)\n#               vect   <- matrix(nrow=nb.h, ncol=2)\n#               vect <- rbind(c(0, 0), vect)\n#               for (i in seq(along=t)) {\n#                 for(j in 1:nb.h) {\n#                   vect[j+1, 1] <- coo.ef$an[j] * cos(j * t[i]) + coo.ef$bn[j] * sin(j * t[i])\n#                   vect[j+1, 2] <- coo.ef$cn[j] * cos(j * t[i]) + coo.ef$dn[j] * sin(j * t[i])}\n#                 vs <- apply(vect, 2, cumsum)\n#                 for (j in 1:nb.h){\n#                   lh   <- efourier.shape(coo.ef$an[1:j], coo.ef$bn[1:j],\n#                                          coo.ef$cn[1:j], coo.ef$dn[1:j],\n#                                          nb.h=j, nb.pts=nb.pts, plot=FALSE)\n#                   ellh <- efourier.shape(coo.ef$an[j], coo.ef$bn[j],\n#                                          coo.ef$cn[j], coo.ef$dn[j],\n#                                          nb.h=1, nb.pts=nb.pts, plot=FALSE)\n#                   lines(lh, col=paste(cols[j], \"22\", sep=\"\"), lwd=0.8)\n#                   lines(ellh$x + vs[j, 1], ellh$y + vs[j, 2],\n#                         col=cols[j], lwd=1)\n#                   points(vs[j+1, 1], vs[j+1, 2], col=cols[j], cex=0.8)\n#                   arrows(vs[j, 1], vs[j, 2], vs[j+1, 1], vs[j+1, 2],\n#                          col=cols[j], angle=10, length=0.05, lwd=1.2)\n#                 }\n#               }\n#               points(0, 0, pch=20, col=cols[1])\n#               if (legend) {\n#                 legend(\"topright\", legend = as.character(1:nb.h), bty=\"o\",\n#                        col = cols, lty = 1, lwd=1, bg=\"#FFFFFFCC\", cex=0.7,\n#                        title = \"Number of harmonics\")}\n#             })\n# \n# \n# # smooth.qual ########################################################\n# setGeneric(name= \"smooth.qual\",   def=function(Coo, id=1,\n#                                                smooth.range = c(10, 50, 200, 500, 1000),\n#                                                palette = col.summer){standardGeneric(\"smooth.qual\")})\n# setMethod(f=\"smooth.qual\", signature=\"Coo\", definition=\n#             function(Coo,\n#                      id=1,\n#                      smooth.range = c(10, 50, 200, 500, 1000),\n#                      palette = col.summer){\n#               cont <- Coo@coo[[id]]\n#               coo.plot(coo.smooth(cont, 0), main = Coo@names[id])\n#               cols <- palette(length(smooth.range))\n#               for (i in seq(along = smooth.range)) {\n#                 lines(coo.smooth(cont, smooth.range[i]), col = cols[i])\n#               }\n#               legend(\"topright\", legend = as.character(smooth.range), \n#                      col = cols, lty = 1, bty = \"o\", bg=\"#FFFFFFCC\", cex=0.7, title = \"Smooth iterations\")})\n",
    "created" : 1396267272261.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "373437072",
    "id" : "7E5F8303",
    "lastKnownWriteTime" : 1396263223,
    "path" : "~/Research/Momocs/R/OutMethods.R",
    "project_path" : "R/OutMethods.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}