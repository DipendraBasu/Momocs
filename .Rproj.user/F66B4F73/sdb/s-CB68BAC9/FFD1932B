{
    "contents" : "\n# Out builder and domestic functions -------------------------------------------\n\n#' Builds an Out object\n#'\n#' In Momocs, Out classes objects are lists of closed outlines, on which generic methods\n#' such as plotting methods (e.g. stack()) and specific methods (e.g. efourier()) can be applied.\n#' \n#' They must be built from a list (or an array) of coordinates.\n#'  \n#' @export Out Coo \n#' \n#' @param coo a matrix of (x,y) coordinates or a \\code{Out} object.\n#' @param ldk (optionnal) a list of landmarks on these coordinates (provided as the row numbers) for every outline\n#' @param fac (optionnal) a data.frame of factors, specifying the grouping structure.\n#' @return a \\code{Out} object.\n#' @aliases Coo\n#' @family Out\n#' @keywords Out\n#' @examples\n#' coo.list <- list(out1=matrix(1:10, nc=2),\n#' out2=matrix(1:20, nc=2))\n#' anOutobject <- Out(coo.list)\n#' anOutobject\n# Out class builder\nOut  <- function(coo.list, ldk=list(), fac=data.frame()){\n  Out <- list(coo=coo.list, ldk=list(), fac=fac)\n  class(Out) <- \"Out\"\n  return(Out)}\n\n# For historical reasons.\n# Before version 1.xxx 'Out' classes used to be S4 classes and called 'Coo'\n# See http://www.jstatsoft.org/v56/i13\nCoo  <- function(coo.list, ldk=list(), fac=data.frame()){\n  Out <- list(coo=coo.list, ldk=list(), fac=fac)\n  class(Out) <- \"Out\"\n  return(Out)}\n\n\n# The print method for Out objects\nprint.Out <- function(Out){\n  ### Header\n  cat(\"An Out object (see ?Out) with: \\n\")\n  cat(rep(\"-\", 20),\"\\n\", sep=\"\")\n  coo.nb  <- length(Out)\n  coo.len <- sapply(Out$coo, nrow)\n  coo.closed <- sapply(Out$coo, is.closed)\n  # number of outlines\n  cat(\" -\", coo.nb, \"outlines\\n\")\n  # one random outline\n  eg <- sample(length(Out), 1)\n  coo.eg <- Out$coo[[eg]]\n  colnames(coo.eg) <- c(\"x\", \"y\")\n  cat(\" - One random outline in $coo: '\", names(Out)[eg], \"':\\n\", sep=\"\")\n  if (nrow(coo.eg) > 5) {\n    print(coo.eg[1:5, ], print.gap=2)\n    cat(\"etc.\\n\")\n  } else {\n    print(coo.eg, print.gap=2)\n    cat(\"\\n\\n\")}\n  # number of coordinates\n  cat(\" -\", round(mean(coo.len )), \"+/-\", round(sd(coo.len )), \"coordinates per outline\\n\")\n  # outlines closed or not\n  if (all(coo.closed)) {\n    cat(\" - All outlines are closed\\n\")\n  } else {\n    if (any(!coo.closed)) {\n      cat(\" - All outlines are unclosed\\n\")\n    } else {\n      cat(\" -\", sum(coo.closed), \"outlines are closed\\n\")}}\n  # number of landmarks\n  if (length(Out$ldk)!=0) {\n    cat(\" -\", length(Out$ldk[[1]]), \"landmark(s) defined\\n\")\n  } else {\n    cat(\" - No landmark defined\\n\")}\n  # number of grouping factors\n  df <- Out$fac\n  nf <- ncol(df)\n  if (nf==0) {\n    cat(\" - No groups defined\\n\")\n  } else {\n    cat(\" -\", nf, \"grouping factor(s) defined:\\n\")\n    for (i in 1:nf) {\n      cat(\"     \", colnames(df)[i], \": \", levels(df[, i]),\"\\n\")}}}\n\n# allows to maintain the tradition str() behaviour\n#' @export str.Out \"[.Out\" \"[[.Out\" length.Out names.Out \"names<-.Out\" print.Out\n#' @export plot.Out stack.Out panel panel.Out \nstr.Out <- function(Out){\n  ls.str(Out)}\n\n# Out can be indexing both to [ ] and [[ ]]\n# and returns the corresponding coordinate(s)\n# We define some getters\n\"[.Out\" <- function(x, i, ...) {\n  if (missing(i))    { return(x$coo[])    }\n  if (is.integer(i)) { return(x$coo[i])   }\n  if (is.numeric(i)) { return(x$coo[[i]]) }}\n\n\"[[.Out\" <- function(x, i, ...) {\n  if (missing(i))    { return(x$coo[])    }\n  if (is.integer(i)) { return(x$coo[i])   }\n  if (is.numeric(i)) { return(x$coo[[i]]) }}\n\n# length on an Out return the length of Out$coo, ie the number of coordinates\nlength.Out <- function(Out) {\n  return(length(Out$coo))}\n\n# names() on a Out retrieves the names of the Out$coo\nnames.Out <- function(Out){\n  return(names(Out$coo))}\n\n# which can in return may be named using names(Out) <- \n\"names<-.Out\" <- function(x, value){\n  names(x$coo) <- value\n  return(x)}\n\nsubset.Out <- function(Out, subset){\n  # candidate for the dirtiest function ever\n  e <- substitute(subset)\n  retain <- eval(e, Out$fac, parent.frame())\n  Out2 <- Out\n  Out2$coo <- Out$coo[retain]\n  if (length(Out$ldk)>0) Out2$ldk <- Out$ldk[retain]\n  if (ncol(Out$fac)>0) {\n    Out2$fac <- Out$fac\n    Out2$fac <- as.data.frame(Out2$fac[retain, ])\n    names(Out2$fac) <- names(Out$fac)\n    for (i in ncol(Out2$fac)){\n      Out2$fac[, i] <- factor(Out2$fac[, i])}\n  }\n  return(Out2)}\n\n\n# Out plotting methods ----------------------------------------------------\n# The main plot method that when plot(Out)\n# For a quick investigation of the shpes included in a Coo object\nplot.Out <- function(Out, id, ...){\n  if (missing(id)) {\n    repeat{\n      id <- sample(length(Out), 1)\n      coo.plot(Out$coo[[id]], main=names(Out)[id], ...)\n      readline(prompt = \"Press <Enter> to continue, <Esc> to quit...\")}}\n  if (id[1]==\"all\") { id <- 1:length(Out)}\n  if (is.numeric(id)){\n    if (length(id)==1) {\n      coo.plot(Out$coo[[id]], main=names(Out)[id], ...)\n    } else {\n      for (i in seq(along=id)) {\n        coo.plot(Out$coo[[id[i]]], main=names(Out)[id[i]], ...)\n        readline(prompt = \"Press <Enter> to continue, <Esc> to quit...\")}}}}\n\n# stack(Out) shows all the shapes stacked on the same plane\nstack.Out <- function(x, cols, borders,\n                      points=FALSE, first.point=TRUE, centroid=TRUE,\n                      ldk=TRUE, ldk.pch=3, ldk.col=\"red\", ldk.cex=1, xy.axis=TRUE){\n  Out <- x\n  if (missing(cols)) {\n    cols     <- rep(NA, length(Out))}\n  if (length(cols)!=length(Out)) {\n    cols     <- rep(cols[1], length(Out))}\n  if (missing(borders)) {\n    borders     <- rep(\"#33333355\", length(Out))}\n  if (length(borders)!=length(Out)) {\n    cols     <- rep(borders[1], length(Out))}\n  op <- par(mar=c(3, 3, 2, 1))\n  on.exit(par(op))\n  wdw <- apply(l2a(lapply(Out$coo, function(x) apply(x, 2, range))), 2, range)\n  plot(NA, xlim=wdw[, 1], ylim=wdw[, 2], asp=1, las=1, cex.axis=2/3, ann=FALSE, frame=FALSE)\n  if (xy.axis) {abline(h=0, v=0, col=\"grey80\", lty=2)}\n  for (i in 1:length(Out)) {\n    coo.draw(Out$coo[[i]], col=cols[i], border=borders[i],\n             points=points, first.point=TRUE, centroid=centroid)}\n  if (ldk & length(Out$ldk)!=0) {\n    points(Out[Out$ldk, ], pch=ldk.pch, col=ldk.col, cex=ldk.cex)}}\n\n# panel(Out) for a family picture of the shapes\npanel <- function(x, ...){UseMethod(\"panel\")}\npanel.Out <- function(Out, cols, borders, names=NULL, cex.names=0.6, ...){\n  \n  if (missing(cols)) {\n    cols     <- rep(\"#33333322\", length(Out))}\n  if (length(cols)!=length(Out)) {\n    cols     <- rep(cols[1], length(Out))}\n  if (missing(borders)) {\n    borders     <- rep(\"#333333\", length(Out))}\n  if (length(borders)!=length(Out)) {\n    cols     <- rep(borders[1], length(Out))}\n  pos <- coo.list.panel(Out$coo, cols=cols, borders=borders, ...)\n  if (!is.null(names)){\n    if (is.logical(names)) {\n      text(pos[,1], pos[,2], labels=names(Out), cex=cex.names)\n    } else {    \n      if (length(names)!=length(Out)) stop(\"* 'names' and Out lengths differ.\")\n      text(pos[,1], pos[,2], labels=names, cex=cex.names)}}}\n",
    "created" : 1396267288966.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1427613596",
    "id" : "FFD1932B",
    "lastKnownWriteTime" : 1396273748,
    "path" : "~/Research/Momocs/R/Out.R",
    "project_path" : "R/Out.R",
    "properties" : {
    },
    "source_on_save" : true,
    "type" : "r_source"
}